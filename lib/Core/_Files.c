/* This code is generated by pOt. */

#include <pOtRTL.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#ifdef __sun__
#include <unistd.h>
#endif

#include "Files.hi"

#define pOt_MaxPathLength_Files 1023

struct pOt__tag_0_Files {
  pOt__ArrTypDsc *td;
  pOt_CHAR arr[0x400L];
} ;
pOt__ArrTypDsc pOt__td_0_Files= {
  1,
  0x400L, sizeof(pOt_CHAR)
};
struct pOt__tag_1_Files {
  pOt__RecTypDsc *td;
  struct pOt__tag_0_Files pOt_name;
  pOt_LONGINT pOt_handle, pOt_pos;
} ;
struct {
  pOt_INTEGER mode;
  pOt_LONGINT size;
  pOt_INTEGER extlev, nstr, nptr, npro;
  pOt__TypDsc *base_td[pOt__MaxExts];
  struct {pOt_LONGINT poffs; pOt__TypDsc *fld_td;} tab[0x1];
} pOt__td_1_Files= {
  0,
  sizeof(struct pOt__tag_1_Files),
  0x0, 0x1, 0x0, 0x0,
  {pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL},
  {
    {(pOt_LONGINT)&((struct pOt__tag_1_Files*)0)->pOt_name, (pOt__TypDsc*)&pOt__td_0_Files}
  }
};
struct pOt__tag_2_Files {
  pOt__RecTypDsc *td;
  pOt_INTEGER pOt_res;
  pOt_BOOLEAN pOt_eof;
  pOt_LONGINT pOt_pos;
  struct pOt__tag_1_Files *pOt_file;
} ;
struct {
  pOt_INTEGER mode;
  pOt_LONGINT size;
  pOt_INTEGER extlev, nstr, nptr, npro;
  pOt__TypDsc *base_td[pOt__MaxExts];
  struct {pOt_LONGINT poffs; pOt__TypDsc *fld_td;} tab[0x1];
} pOt__td_2_Files= {
  0,
  sizeof(struct pOt__tag_2_Files),
  0x0, 0x0, 0x1, 0x0,
  {pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL, pOt_NIL},
  {
    {(pOt_LONGINT)&((struct pOt__tag_2_Files*)0)->pOt_file, pOt_NIL}
  }
};

typedef struct pOt__tag_1_Files *pOt_File_Files;
typedef struct pOt__tag_1_Files pOt_FileDesc_Files;
typedef struct pOt__tag_2_Files pOt_Rider_Files;
pOt_File_Files pOt_StdIn_Files, pOt_StdOut_Files, pOt_StdErr_Files;

static struct {void *next, *vars[0x4L];} pOt__gc_ptrs = {pOt_NIL,{
  &pOt_StdIn_Files,
  &pOt_StdOut_Files,
  &pOt_StdErr_Files,
  pOt_NIL
}};
static struct {void *next, *vars[0x1L];} pOt__gc_strs = {&pOt__gc_ptrs,{
  pOt_NIL
}};

extern pOt_File_Files pOt_Old_Files(pOt_name)
	pOt__DynArr *pOt_name;
{
  pOt_File_Files pOt__retval;
  pOt_File_Files pOt_f;
  FILE *handle;
  pOt_LONGINT i, j;
  char empty[1];
  pOt_CHAR *dlist, *fullname;

  struct {void *next, *vars[0x2L];} pOt__gc_ptrs;
  struct {void *next, *vars[0x1L];} pOt__gc_strs;
  pOt__gc_ptrs.next = pOt__gc_root;
  pOt__gc_strs.next = &pOt__gc_ptrs;
  pOt__gc_ptrs.vars[1L]=pOt_NIL;
  pOt__gc_strs.vars[0L]=pOt_NIL;
  pOt__gc_ptrs.vars[0L]=&pOt_f;
  pOt__gc_root=(struct pOt__tag_gc_node*)&pOt__gc_strs;
  pOt_f=pOt_NIL;

	empty[0] = '\0';
  dlist = getenv("POTLAND");
  fullname = (char*)malloc(pOt_MaxPathLength_Files+1);
  if(dlist == NULL) dlist = empty;
  i = 0; j = 0;
  for(;;) {
    fullname[j] = '\0';
    if(strlen(fullname)+strlen((char*)(pOt_name+1))>=pOt_MaxPathLength_Files) pOt__halt(__FILE__,__LINE__,3);
    strcat(fullname, (char*)(pOt_name + 1));
    handle = fopen(fullname,
#ifdef __MSDOS__
      "r+b"
#else 
      "r+"
#endif    
    );
    if(!handle)
      handle = fopen(fullname,
#ifdef __MSDOS__
        "rb"
#else 
        "r"
#endif    
      );
    if(handle != NULL) {
      pOt__new(__FILE__,__LINE__,(pOt__TypDsc***)&pOt_f,(pOt__TypDsc*)&pOt__td_1_Files);
      (*pOt_f).pOt_handle=(pOt_LONGINT)(handle);
      (*pOt_f).pOt_pos=(pOt_LONGINT)(0);
      pOt__copy((pOt_CHAR*)&(*pOt_name),(pOt_CHAR*)&(*pOt_f).pOt_name);
      break;
    }
    if(dlist[i] =='\0') break;
    j = 0;
    while((dlist[i] != '\0') && (dlist[i] !=
#ifdef __MSDOS__
      ';'
#else 
      ':'
#endif
    )) fullname[j==pOt_MaxPathLength_Files?pOt__halt(__FILE__,__LINE__,3),j:j++] = dlist[i++];
    if(dlist[i] != '\0') i++;
  }  
  free(fullname);

  pOt__retval =(struct pOt__tag_1_Files*)(pOt_f);
  goto pOt__Epilogue;

  pOt__halt(__FILE__,__LINE__,0x11);
pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
  pOt__rm_par((pOt__TypDsc**)pOt_name);
  return pOt__retval;
}



extern pOt_File_Files pOt_New_Files(pOt_name) pOt__DynArr *pOt_name;
{
  pOt_File_Files pOt__retval;
  pOt_File_Files pOt_f;
  FILE *handle;
  struct {void *next, *vars[0x2L];} pOt__gc_ptrs;
  struct {void *next, *vars[0x1L];} pOt__gc_strs;
  pOt__gc_ptrs.next = pOt__gc_root;
  pOt__gc_strs.next = &pOt__gc_ptrs;
  pOt__gc_ptrs.vars[1L]=pOt_NIL;
  pOt__gc_strs.vars[0L]=pOt_NIL;
  pOt__gc_ptrs.vars[0L]=&pOt_f;
  pOt__gc_root=(struct pOt__tag_gc_node*)&pOt__gc_strs;
  pOt_f=pOt_NIL;

  handle = 
    *(char*)(pOt_name+1) == '\0' ?
      tmpfile() /* if the name is empty, the file is temporary */
    : fopen((char*)(pOt_name + 1), 
#ifdef __MSDOS__
	"w+b"
#else 
	"w+"
#endif    
      );
  if(handle != NULL) {
    pOt__new(__FILE__,__LINE__,(pOt__TypDsc***)&pOt_f,(pOt__TypDsc*)&pOt__td_1_Files);
    (*pOt_f).pOt_handle=(pOt_LONGINT)(handle);
    (*pOt_f).pOt_pos=(pOt_LONGINT)(0);
    pOt__copy((pOt_CHAR*)&(*pOt_name),(pOt_CHAR*)&(*pOt_f).pOt_name);
  }
  pOt__retval =(struct pOt__tag_1_Files*)(pOt_f);
  goto pOt__Epilogue;

  pOt__halt(__FILE__,__LINE__,0x11);
pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
  pOt__rm_par((pOt__TypDsc**)pOt_name);
  return pOt__retval;
}

extern void pOt_Register_Files(pOt_f) pOt_File_Files pOt_f;
{
  struct {void *next, *vars[0x2L];} pOt__gc_ptrs;
  struct {void *next, *vars[0x1L];} pOt__gc_strs;
  pOt__gc_ptrs.next = pOt__gc_root;
  pOt__gc_strs.next = &pOt__gc_ptrs;
  pOt__gc_ptrs.vars[1L]=pOt_NIL;
  pOt__gc_strs.vars[0L]=pOt_NIL;
  pOt__gc_ptrs.vars[0L]=&pOt_f;
  pOt__gc_root=(struct pOt__tag_gc_node*)&pOt__gc_strs;

  fclose((FILE*)pOt_f->pOt_handle);
  pOt_f=(struct pOt__tag_1_Files*)(pOt_NIL);

pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
}



extern void pOt_Close_Files(pOt_f) pOt_File_Files pOt_f;
{
  struct {void *next, *vars[0x2L];} pOt__gc_ptrs;
  struct {void *next, *vars[0x1L];} pOt__gc_strs;
  pOt__gc_ptrs.next = pOt__gc_root;
  pOt__gc_strs.next = &pOt__gc_ptrs;
  pOt__gc_ptrs.vars[1L]=pOt_NIL;
  pOt__gc_strs.vars[0L]=pOt_NIL;
  pOt__gc_ptrs.vars[0L]=&pOt_f;
  pOt__gc_root=(struct pOt__tag_gc_node*)&pOt__gc_strs;

  fclose((FILE*)pOt_f->pOt_handle);
  pOt_f=(struct pOt__tag_1_Files*)(pOt_NIL);

pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
}

extern void pOt_Purge_Files(pOt_f) pOt_File_Files pOt_f;
{
  struct {void *next, *vars[0x2L];} pOt__gc_ptrs;
  struct {void *next, *vars[0x1L];} pOt__gc_strs;
  pOt__gc_ptrs.next = pOt__gc_root;
  pOt__gc_strs.next = &pOt__gc_ptrs;
  pOt__gc_ptrs.vars[1L]=pOt_NIL;
  pOt__gc_strs.vars[0L]=pOt_NIL;
  pOt__gc_ptrs.vars[0L]=&pOt_f;
  pOt__gc_root=(struct pOt__tag_gc_node*)&pOt__gc_strs;

  fclose((FILE*)pOt_f->pOt_handle); unlink(pOt_f->pOt_name.arr);
  pOt_f=(struct pOt__tag_1_Files*)(pOt_NIL);

pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
}

extern pOt_LONGINT pOt_Length_Files(pOt_f) pOt_File_Files pOt_f;
{
  pOt_LONGINT pOt_pos, pOt_len;
  pOt_LONGINT pOt__retval;
  struct {void *next, *vars[0x2L];} pOt__gc_ptrs;
  struct {void *next, *vars[0x1L];} pOt__gc_strs;
  pOt__gc_ptrs.next = pOt__gc_root;
  pOt__gc_strs.next = &pOt__gc_ptrs;
  pOt__gc_ptrs.vars[1L]=pOt_NIL;
  pOt__gc_strs.vars[0L]=pOt_NIL;
  pOt__gc_ptrs.vars[0L]=&pOt_f;
  pOt__gc_root=(struct pOt__tag_gc_node*)&pOt__gc_strs;

  pOt_pos = ftell((FILE*)pOt_f->pOt_handle);
  fseek((FILE*)pOt_f->pOt_handle, 0, SEEK_END);
  pOt_len = ftell((FILE*)pOt_f->pOt_handle);
  fseek((FILE*)pOt_f->pOt_handle, pOt_pos, SEEK_SET);
  pOt__retval = pOt_len;
  goto pOt__Epilogue;

  pOt__halt(__FILE__,__LINE__,0x11);
pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
  return pOt__retval;
}

extern void pOt_Set_Files(pOt_r, pOt_f, pOt_pos)
	struct pOt__tag_2_Files *pOt_r; pOt_File_Files pOt_f; pOt_LONGINT pOt_pos;
{
  struct {void *next, *vars[0x2L];} pOt__gc_ptrs;
  struct {void *next, *vars[0x1L];} pOt__gc_strs;
  pOt__gc_ptrs.next = pOt__gc_root;
  pOt__gc_strs.next = &pOt__gc_ptrs;
  pOt__gc_ptrs.vars[1L]=pOt_NIL;
  pOt__gc_strs.vars[0L]=pOt_NIL;
  pOt__gc_ptrs.vars[0L]=&pOt_f;
  pOt__gc_root=(struct pOt__tag_gc_node*)&pOt__gc_strs;

  pOt_r->pOt_file = pOt_f;
  if(pOt_r->pOt_file != pOt_NIL) {
    pOt_r->pOt_pos = pOt_pos; pOt_f->pOt_pos = pOt_pos;
    pOt_r->pOt_eof = pOt_FALSE;
    pOt_r->pOt_res = fseek((FILE*)pOt_f->pOt_handle, pOt_pos, SEEK_SET);
  } else {
    pOt_r->pOt_pos = -1; pOt_r->pOt_eof = pOt_TRUE;
    pOt_r->pOt_res = -1;
  }

pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
}

extern void pOt_Read_Files(pOt_r, pOt_x)
	struct pOt__tag_2_Files *pOt_r; pOt_BYTE_SYSTEM *pOt_x;
{
  struct {void*next;} pOt__gc_ptrs;
  pOt__gc_ptrs.next = pOt__gc_root;

  if(pOt_r->pOt_pos != pOt_r->pOt_file->pOt_pos) {
    fseek((FILE*)pOt_r->pOt_file->pOt_handle, pOt_r->pOt_pos, SEEK_SET);
    pOt_r->pOt_file->pOt_pos = pOt_r->pOt_pos;
  }
  pOt_r->pOt_res= fread((void*)pOt_x, 1, 1, (FILE*)pOt_r->pOt_file->pOt_handle);
  if(ferror((FILE*)pOt_r->pOt_file->pOt_handle)) pOt__halt(__FILE__,__LINE__,23);
  if(feof((FILE*)pOt_r->pOt_file->pOt_handle)) {
    *pOt_x = 0; pOt_r->pOt_res = 0; pOt_r->pOt_eof = pOt_TRUE;
  } else {
    pOt_r->pOt_file->pOt_pos = ++pOt_r->pOt_pos;
  }

pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
}

extern void pOt_ReadBytes_Files(pOt_r,pOt_x,pOt_n)
	struct pOt__tag_2_Files *pOt_r; pOt__BytArr pOt_x; pOt_LONGINT pOt_n;
{
  struct {void*next;} pOt__gc_ptrs;
  pOt__gc_ptrs.next = pOt__gc_root;

  if(pOt_x.len < pOt_n) pOt__halt(__FILE__,__LINE__,3);
  if(pOt_r->pOt_pos != pOt_r->pOt_file->pOt_pos) {
    fseek((FILE*)pOt_r->pOt_file->pOt_handle, pOt_r->pOt_pos, SEEK_SET);
    pOt_r->pOt_file->pOt_pos = pOt_r->pOt_pos;
  }
  pOt_n = pOt_r->pOt_res = fread((void*)pOt_x.data, 1, pOt_n, (FILE*)pOt_r->pOt_file->pOt_handle);
  if(ferror((FILE*)pOt_r->pOt_file->pOt_handle)) pOt__halt(__FILE__,__LINE__,23);
  if(feof((FILE*)pOt_r->pOt_file->pOt_handle)) {
    pOt_r->pOt_eof = pOt_TRUE;
  }
  pOt_r->pOt_file->pOt_pos = (pOt_r->pOt_pos += pOt_n);

pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
}

extern void pOt_Write_Files(pOt_r, pOt_x)
	struct pOt__tag_2_Files *pOt_r; pOt_BYTE_SYSTEM pOt_x;
{
  struct {void*next;} pOt__gc_ptrs;
  pOt__gc_ptrs.next = pOt__gc_root;

  if(pOt_r->pOt_pos != pOt_r->pOt_file->pOt_pos) {
    fseek((FILE*)pOt_r->pOt_file->pOt_handle, pOt_r->pOt_pos, SEEK_SET);
    pOt_r->pOt_file->pOt_pos = pOt_r->pOt_pos;
  }
  pOt_r->pOt_res = fwrite((void*)&pOt_x, 1, 1, (FILE*)pOt_r->pOt_file->pOt_handle);
  if(ferror((FILE*)pOt_r->pOt_file->pOt_handle)) pOt__halt(__FILE__,__LINE__,24);
  pOt_r->pOt_file->pOt_pos = ++pOt_r->pOt_pos;

pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
}

extern void pOt_WriteBytes_Files(pOt_r, pOt_x, pOt_n)
	struct pOt__tag_2_Files *pOt_r; pOt__BytArr pOt_x; pOt_LONGINT pOt_n;
{
  struct {void*next;} pOt__gc_ptrs;
  pOt__gc_ptrs.next = pOt__gc_root;

  if(pOt_x.len < pOt_n) {
    pOt__halt(__FILE__,__LINE__,3);
  }  
  if(pOt_r->pOt_pos != pOt_r->pOt_file->pOt_pos) {
    fseek((FILE*)pOt_r->pOt_file->pOt_handle, pOt_r->pOt_pos, SEEK_SET);
    pOt_r->pOt_file->pOt_pos = pOt_r->pOt_pos;
  }
  pOt_n = pOt_r->pOt_res = fwrite((void*)pOt_x.data, 1, pOt_n, (FILE*)pOt_r->pOt_file->pOt_handle);
  if(ferror((FILE*)pOt_r->pOt_file->pOt_handle)) pOt__halt(__FILE__,__LINE__,24);
  pOt_r->pOt_file->pOt_pos = (pOt_r->pOt_pos += pOt_n);

pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
}

extern pOt_LONGINT pOt_Pos_Files(pOt_r)
	struct pOt__tag_2_Files *pOt_r;
{
  pOt_LONGINT pOt__retval;
  struct {void*next;} pOt__gc_ptrs;
  pOt__gc_ptrs.next = pOt__gc_root;

  pOt__retval =(pOt_LONGINT)((*pOt_r).pOt_pos);
  goto pOt__Epilogue;

  pOt__halt(__FILE__,__LINE__,0x11);
pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
  return pOt__retval;
}

extern pOt_File_Files pOt_Base_Files(pOt_r)
	struct pOt__tag_2_Files *pOt_r;
{
  pOt_File_Files pOt__retval;
  struct {void*next;} pOt__gc_ptrs;
  pOt__gc_ptrs.next = pOt__gc_root;

  pOt__retval =(struct pOt__tag_1_Files*)((*pOt_r).pOt_file);
  goto pOt__Epilogue;

  pOt__halt(__FILE__,__LINE__,0x11);
pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
  return pOt__retval;
}

extern void pOt_Rename_Files(pOt_old, pOt_new, pOt_res)
	pOt__DynArr *pOt_old; pOt__DynArr *pOt_new; pOt_INTEGER *pOt_res;
{
  struct {void*next;} pOt__gc_ptrs;
  pOt__gc_ptrs.next = pOt__gc_root;

  *pOt_res = rename((char*)(pOt_old+1),(char*)(pOt_new+1));

pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
  pOt__rm_par((pOt__TypDsc**)pOt_old);
  pOt__rm_par((pOt__TypDsc**)pOt_new);
}

extern void pOt_Delete_Files(pOt_name, pOt_res)
	pOt__DynArr *pOt_name; pOt_INTEGER *pOt_res;
{
  struct {void*next;} pOt__gc_ptrs;
  pOt__gc_ptrs.next = pOt__gc_root;

  *pOt_res = unlink((char*)(pOt_name+1));

pOt__Epilogue:;
  pOt__gc_root=(struct pOt__tag_gc_node*)pOt__gc_ptrs.next;
  pOt__rm_par((pOt__TypDsc**)pOt_name);
}

void pOt_Files__body()
{
  static int pOt_Files__loaded=0;
  if(!pOt_Files__loaded){
    pOt_Files__loaded=1;

    pOt__gc_ptrs.next=pOt__gc_root;
    pOt__gc_root=(struct pOt__tag_gc_node*)&pOt__gc_strs;

    pOt_StdIn_Files=pOt_NIL;
    pOt_StdOut_Files=pOt_NIL;
    pOt_StdErr_Files=pOt_NIL;

    pOt__new(__FILE__,__LINE__,(pOt__TypDsc***)&pOt_StdIn_Files,(pOt__TypDsc*)&pOt__td_1_Files);
    (*pOt_StdIn_Files).pOt_pos=(pOt_LONGINT)(0);
    pOt__arr_assign((pOt__ArrTypDsc**)& (*pOt_StdIn_Files).pOt_name,(pOt__ArrTypDsc**)&(*pOt__set_str_td(&pOt__strcon_buf[0x0L],&pOt__td_0_Files)));
    (*pOt_StdIn_Files).pOt_handle=(pOt_LONGINT)(stdin);
    pOt__new(__FILE__,__LINE__,(pOt__TypDsc***)&pOt_StdOut_Files,(pOt__TypDsc*)&pOt__td_1_Files);
    (*pOt_StdOut_Files).pOt_pos=(pOt_LONGINT)(0);
    pOt__arr_assign((pOt__ArrTypDsc**)& (*pOt_StdOut_Files).pOt_name,(pOt__ArrTypDsc**)&(*pOt__set_str_td(&pOt__strcon_buf[0x0L],&pOt__td_0_Files)));
    (*pOt_StdOut_Files).pOt_handle=(pOt_LONGINT)(stdout);
    pOt__new(__FILE__,__LINE__,(pOt__TypDsc***)&pOt_StdErr_Files,(pOt__TypDsc*)&pOt__td_1_Files);
    (*pOt_StdErr_Files).pOt_pos=(pOt_LONGINT)(0);
    pOt__arr_assign((pOt__ArrTypDsc**)& (*pOt_StdErr_Files).pOt_name,(pOt__ArrTypDsc**)&(*pOt__set_str_td(&pOt__strcon_buf[0x0L],&pOt__td_0_Files)));
    (*pOt_StdErr_Files).pOt_handle=(pOt_LONGINT)(stderr);

  pOt__Epilogue:;
  }
}
